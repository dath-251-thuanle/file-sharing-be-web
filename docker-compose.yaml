# Unified Docker Compose for Backend + Frontend + Nginx

services:
  # ==================== DATABASE ====================
  # NOTE: This service is only for local development
  # Production uses external database (e.g., Aiven)
  # Set DB_HOST, DB_USER, DB_PASSWORD, DB_NAME, DB_PORT, DB_SSLMODE in .env for external DB
  postgres:
    image: postgres:15-alpine
    container_name: file-sharing-db
    environment:
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-postgres}
      POSTGRES_DB: ${DB_NAME:-file_sharing_db}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=en_US.UTF-8"
    ports:
      - "${DB_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/pkg/database/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres} -d ${DB_NAME:-file_sharing_db}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - app-network
    restart: unless-stopped

  # ==================== DATABASE MIGRATIONS ====================
  # NOTE: This service connects to database specified in .env (DB_HOST, DB_USER, etc.)
  # For Aiven: Set DB_HOST to Aiven hostname, DB_USER to Aiven username, DB_SSLMODE=require
  migrate:
    image: migrate/migrate:latest
    container_name: file-sharing-migrate
    volumes:
      - ./backend/migrations:/migrations
    env_file:
      - .env
    environment:
      - DB_HOST=${DB_HOST:-postgres}
      - DB_PORT=${DB_PORT:-5432}
      - DB_USER=${DB_USER:-postgres}
      - DB_PASSWORD=${DB_PASSWORD:-postgres}
      - DB_NAME=${DB_NAME:-file_sharing_db}
      - DB_SSLMODE=${DB_SSLMODE:-disable}
    networks:
      - app-network
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        set +e
        echo "Running migrations with database: $${DB_HOST}:$${DB_PORT}/$${DB_NAME}"
        echo "Waiting for database connection..."
        DB_URL="postgres://$${DB_USER}:$${DB_PASSWORD}@$${DB_HOST}:$${DB_PORT}/$${DB_NAME}?sslmode=$${DB_SSLMODE}"
        
        # Wait for database to be ready (using migrate version as health check)
        for i in 1 2 3 4 5 6 7 8 9 10; do
          if migrate -path /migrations -database "$${DB_URL}" version > /dev/null 2>&1; then
            echo "Database is ready!"
            break
          fi
          # Also try to connect directly (migrate may fail for other reasons)
          if [ $$i -eq 10 ]; then
            echo "Warning: Could not verify database connection, but proceeding anyway..."
          else
            echo "Attempt $$i/10: Database not ready, waiting 2 seconds..."
            sleep 2
          fi
        done
        
        # Check migration version
        echo "Checking current migration version..."
        VERSION_OUTPUT=$(migrate -path /migrations -database "$${DB_URL}" version 2>&1)
        VERSION_EXIT_CODE=$$?
        
        # If version check fails, it might mean:
        # 1. Migration table doesn't exist (fresh DB)
        # 2. Tables already exist from schema.sql but migration version not set
        # Try to run migrations first
        echo "Running migrations..."
        MIGRATE_OUTPUT=$(migrate -path /migrations -database "$${DB_URL}" up 2>&1)
        MIGRATE_EXIT_CODE=$$?
        
        # If migration fails with "already exists" error, force version and retry
        if [ $$MIGRATE_EXIT_CODE -ne 0 ] && echo "$${MIGRATE_OUTPUT}" | grep -qi "already exists\|relation.*already exists"; then
          echo "Detected existing tables. Setting migration version to 1..."
          migrate -path /migrations -database "$${DB_URL}" force 1 2>&1 || true
          echo "Retrying migrations..."
          migrate -path /migrations -database "$${DB_URL}" up
        elif [ $$MIGRATE_EXIT_CODE -ne 0 ]; then
          echo "Migration failed:"
          echo "$${MIGRATE_OUTPUT}"
          exit $$MIGRATE_EXIT_CODE
        else
          echo "Migrations completed successfully!"
        fi
    restart: "no"
    # Note: depends_on removed to allow external database (Aiven)
    # If using local postgres, it will retry until connection is available

  # ==================== BACKEND - DEVELOPMENT ====================
  app-dev:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    container_name: file-sharing-app-dev
    env_file:
      - .env
    environment:
      - APP_ENV=development
      - APP_PORT=8080
      - DB_HOST=${DB_HOST:-postgres}
      - DB_PORT=${DB_PORT:-5432}
      - DB_USER=${DB_USER:-postgres}
      - DB_PASSWORD=${DB_PASSWORD:-postgres}
      - DB_NAME=${DB_NAME:-file_sharing_db}
      - DB_SSLMODE=${DB_SSLMODE:-disable}
      - RUN_DB_MIGRATIONS=${RUN_DB_MIGRATIONS:-true}
      - MIGRATIONS_PATH=${MIGRATIONS_PATH:-migrations}
      - JWT_SECRET=${JWT_SECRET:-dev_secret_key_minimum_32_characters_long}
      - STORAGE_PATH=/app/storage/uploads
      - CLOUD_STORAGE_ENABLED=${CLOUD_STORAGE_ENABLED:-true}
      - CLOUD_STORAGE_PROVIDER=${CLOUD_STORAGE_PROVIDER:-azure}
      - CLOUD_STORAGE_ENDPOINT=${CLOUD_STORAGE_ENDPOINT:-https://dathhcmut20251.blob.core.windows.net}
      - CLOUD_STORAGE_ACCESS_KEY=${CLOUD_STORAGE_ACCESS_KEY:-dathhcmut20251}
      - CLOUD_STORAGE_SECRET_KEY=${CLOUD_STORAGE_SECRET_KEY}
      - CLOUD_STORAGE_PUBLIC_CONTAINER=${CLOUD_STORAGE_PUBLIC_CONTAINER:-public-file}
      - CLOUD_STORAGE_PRIVATE_CONTAINER=${CLOUD_STORAGE_PRIVATE_CONTAINER:-private-file}
      - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-http://localhost:3000,http://localhost:8080,http://127.0.0.1:3000,http://127.0.0.1:8080}
      - CORS_ALLOWED_METHODS=${CORS_ALLOWED_METHODS:-GET,POST,PUT,DELETE,PATCH,OPTIONS}
      - CORS_ALLOWED_HEADERS=${CORS_ALLOWED_HEADERS:-Origin,Content-Type,Content-Length,Accept-Encoding,X-CSRF-Token,Authorization,X-Cron-Secret}
    ports:
      - "8080:8080"
    volumes:
      - ./backend:/app
      - app_storage:/app/storage/uploads
      - go_modules:/go/pkg/mod
    networks:
      - app-network
    depends_on:
      migrate:
        condition: service_completed_successfully
      # postgres dependency removed to allow external database (Aiven)
      # App will retry database connection automatically
    restart: unless-stopped

  # ==================== PRODUCTION - ALL-IN-ONE (Backend + Frontend + Nginx) ====================
  # This service uses pre-built image from DockerHub containing:
  # - Backend (Go server on port 8080)
  # - Frontend (Next.js on port 3000)
  # - Nginx (reverse proxy on port 80)
  # All managed by Supervisor in a single container
  app:
    image: playernem/dath20251_file-sharing:latest
    container_name: file-sharing-app
    env_file:
      - .env
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - app_storage:/app/storage/uploads
    networks:
      - app-network
    depends_on:
      migrate:
        condition: service_completed_successfully
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    profiles:
      - production

  # ==================== FRONTEND - DEVELOPMENT ====================
  frontend-dev:
    build:
      context: ./frontend
      dockerfile: frontend.Dockerfile.dev
    container_name: file-sharing-frontend-dev
    environment:
      - NEXT_PUBLIC_API_URL=
      - BACKEND_URL=http://app-dev:8080
      - NODE_ENV=development
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - frontend_node_modules:/app/node_modules
      - frontend_next:/app/.next
    networks:
      - app-network
    restart: unless-stopped
    profiles:
      - dev

  # ==================== NGINX REVERSE PROXY - DEVELOPMENT ====================
  nginx-dev:
    image: nginx:alpine
    container_name: file-sharing-nginx-dev
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.dev.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      app-dev:
        condition: service_started
      frontend-dev:
        condition: service_started
    networks:
      - app-network
    restart: unless-stopped
    profiles:
      - dev

  # Note: Production nginx is included in the all-in-one 'app' service above
  # No separate nginx service needed for production

  # ==================== ADMINER (Database Management) ====================
  adminer:
    image: adminer:latest
    container_name: file-sharing-adminer
    ports:
      - "8081:8080"
    environment:
      ADMINER_DEFAULT_SERVER: postgres
    depends_on:
      - postgres
    networks:
      - app-network
    restart: unless-stopped
    profiles:
      - dev
      - tools

volumes:
  postgres_data:
    driver: local
  app_storage:
    driver: local
  go_modules:
    driver: local
  frontend_node_modules:
    driver: local
  frontend_next:
    driver: local

networks:
  app-network:
    driver: bridge